* License:
[[http://www.gnu.org/licenses/gpl-3.0.txt][GPLv3]] (or later, at the discretion of Eric Wong), except where noted.
* Prerequisite Knowledge / Conventions used
** Prerequisite Knowledge
+ You should know basic Ruby syntax.
+ Bourne shell knowledge will be useful, but not required.
+ You do not need to know C, though it will be referred to and Ruby methods will
  be mapped to corresponding or analogous C functions.
+ You must know that two[fn:1] variables in Ruby can refer to the same
  object. This concept is present in Unix, so it is *very* important to
  understand the following:

  #+begin_src ruby
    a = "this is a string"
    b = a    # 'b' refers to the same String object
    a << "!" # modifies the String object 'a' points to

    "this is a string!" == a

    # You should understand why the following statements are true:
    "this is a string!" == b
    "this is a string" != b
  #+end_src
** Notations / Conventions
*** Ruby method documentation references
should be the same as Ruby documentation

+ IO.pipe :: class/singleton method
+ IO#stat :: instance method
*** C function documentation references

+ pipe(2) :: "#{function_name}(#{section})"
             The C function manpage can be accessed as:
               man #{section} #{function_name}
             so [[shell:man%202%20pipe][man 2 pipe]] for pipe(2)
* A Fluffy Introduction to Unix Systems Programmng in Ruby
** What is Unix?
Unix is an operating system originally developed at Bell Labs n 1969. Numerous
versions and clones ("Unix-like" systems) have been released over the decades as
the Unix family continues to evolve. Nowadays, POSIX is the set of standards
that attempt to define the interfaces of Unix and Unix-like systems[fn:2].

Modern Unix systems have two distinct software layers, user space and kernel
space, which layer like so:

User space   (user applications, where Ruby runs)
--------------------------------------------------
Kernel space (schedulers, sockets, pipes, VFS ...)
--------------------------------------------------
Hardware     (disks, network cards, memory)

The kernel acts as a mediator for user space and the underlying hardware.
** What is Unix systems programmng?
Unix and Unix-like operating systems share a set of common programming
interfaces for user space to interact with the kernel, and in turn
hardware. These interfaces are referred to as "system calls"[fn:3] or
"syscalls".

We'll be interacting with Unix and Unix-like operating systems using the Ruby
programming language.

Unix systems programming is often thought of as "plumbing" as it deals with
basic infrastructure and data flow in and out of the system.
** Why Unix?
Unix and Unix-like systems are everywhere. From traditional deployments on
workstations and servers, to smartphones and tablets, Unix and its clones have
become pervasive in the world of computing over the past four decades and are
showing no sign of decline.

Many implementations of Unix and its clones are free[fn:4], so it's readily
available for anybody with the time and will to study.

The design of Unix is minimalist and simple. While there have been undeniable
missteps and embarassing mistakes over the years, its systems programming
interface remains absolutely consistent and straightforward.
** Why systems programming?
Knowledge of systems programming is often useful for understanding,
troubleshooting and debugging problems in high-level applications. *Lack* of
systems programming knowledge and understanding can cause problems in both the
design and implementation of applications.

Unix systems programming knowledge transcends programming languages. As long as
an application runs on a Unix-like system, Unix systems programming knowledge
will be useful for implementing, improving, and troubleshooting applications.
** Why Ruby?
Traditionally, Unix systems programming is taught in C, but high-level languages
like Perl, Python and Ruby can access most of the same Unix APIs available to C
programmers.

Unlike C, Ruby is a very forgiving language. There is no pointer manipulation
and no manual memory management. The Rubyist does not need to worry about many
common bugs found in C code.

Error handling is also enforced in Ruby. While C programmers should check for
errors on every syscall, Rubyists have SystemCallExceptions(Errno::*) thrown in
their face when errors are encountered.

As far as the author knows, there is little documentation on Unix systems
programming in Ruby (or languages other than C for that matter). Given the
prevalance of programmers working in high-level languages that do not know C,
Unix systems programming knowledge may have been off limits to many.

* The Unix Object Model (as seen from user space)
A running Unix/Unix-like kernel exposes two primary types of object to
userspace, Processes and Open Files.
** Processes
Processes are instances of running applications. Ruby programs typically run as
their own process[fn:5] in userspace.

Kernels expose a Process IDentfier (PID) as positive integers to userspace
programs so they can be uniquely identified. Each PID represents one (private)
process object in the kernel. The PID is just a reference or ponter to that
object. Two running processes cannot have the same PID, and two PIDs cannot
refer to the same process, but PIDs can be recycled and reused over time.

PIDs are global in scope to each running Unix system.

Processes are created from their parent using the [[shell:man%202%20fork][fork(2)]] system call. Ruby
wraps this method in Kernel#fork.
** Open Files
Running processes may create, open, and release objects known as "files" in
kernel space usng the APIs provided in user space. Much of Unix systems
programmng revolves around manipulating "file" objects of various types.

The kernel exposes non-negative integers known as "file descriptors" to
userspace. These are similar to PIDs as they are integers which point to objects
within the kernel.

One of the design goals of Unix was "everything is a file", and indeed each file
descriptor may refer to one of several types of objects within a running
kernel. All of these objects can be called "files" regardless of them being
stored on hard disks or visible on the filesystem.

File descripters may be reused and recycled within the lifetime of a
process. They are more frequently recycled than PIDs.

Each process has its own file descriptor table, inherited from its parent.

Unlike PIDs, several file descriptors may refer to the same file object inside
the kernel.

File descriptors have properties of their own that are not tied to the
underlying file object in the kernel.

Open files are the primary interface for processes to interact with the kernel.
** Summary
Processes are containers for open files, among other thngs. Open files are
objects in the Unix kernel that can be accessed from within processes.
* An Overview of the Unix Filesystem
Unix has a heirarchical filesystem visible to all running processes, and it is
the primary shared namespace within a Unix system.

The top (or root) of this namespace starts at "/", and subdirectories may be
created under it, each path component separated by "/".

Filesystems may contain other filesystems. The root filesystem on a modern Unix
almost always contans other filesystems.

Filesystems may have several types of files:

+ directories
+ symlinks
+ UNIX domain sockets
+ FIFOs
+ character devices
+ block devices
+ "regular" files


Traditional filesystems are backed by stable storage (hard drives, SSD) and
persist across reboots and shutdowns. Some of these are designed for Unix and
are considered POSIX-compliant, while others were designed for other OSes and
are incompatible with POSIX to various degrees.

Various pseudo-filesystems exist, but they are mostly non-standardized. Among
pseudo-filesystems, there are:

+ memory-only filesystems
+ network filesystems
+ proc (process information) filesystems
+ device filesystems
+ filesystems for tuning/inspecting the kernel and hardware


Pseudo-filesystems allow Unix-based OSes to avoid implementng system calls only
useful within a limited scope.

The "everything-is-a-file" design and use of filesystems[fn:6] allows a few
system calls to be useful for multiple purposes. This consistency improves the
user experience by reducing the amount a systems programmer needs to know, and
also improving the discoverability of the interfaces.

As the amount of system calls is relatively small, learning Unix systems
programming should be easier than in other operating systems.

Plan 9[fn:7] takes "everything-is-a-file" more literally to further minimize the
need for specialized system calls. This Plan 9 idea[fn:8] is being co-opted into
existing userspaces and operating systems.

* Traditional Unix Filesystem Behavior
POSIX-compliant filesystems are the standard, other[fn:9] filesystems attempt to
expose a user-interface simlar to those in POSIX-compliant
filesystems. Unfortunately, this means there are sometimes leaky, incompatible,
and even dangerous abstractions that may be present.

Unix filesystems are byte-oriented. They have no notion of encodings, and thus
cannot be case-insensitive. They do not normalize path names or data in any
way. The lack of conversion and normalization makes path lookup operations fast.

In a path name, only the "\0" byte is disallowed. The "/" byte is used to
delimit directores, so it may not exist in a path component itself. Otherwise,
path names may contain any other value.

Regular files will store any bnary data stream without altering it in the
kernel. Filesystem operations have no notion of "lines" and won't convert CRLF
line endings to LF or vice-versa.

There are many filesystem operations defned to be atomic in POSIX. These are
ideal for helping multiple processes interact with each other
safely. Unfortunately, they also make POSIX-compliance difficult for
implementations of network and distributed filesystems.
* System Calls in Unix
Syscalls are the interface that user space uses to interact with kernel
space. When a user space application makes a syscall, it's telling the kernel to
execute code on its behalf.

Ruby provides a global "syscall" method on many platforms. It's useful for
learning and experimentation, but not recommended for general use as it is
fragile and non-portable. There is usually no need to use this method as many
useful syscalls are already provided and wrapped by Ruby methods.

For a user space application to make a system call, architechture and
OS-dependent code must be invoked. At the lowest userspace levels, this is
implemented in non-portable assembly code.

Fortunately, most system calls are already provided as wrappers by the system C
library[fn:10] so they appear to user space as portable C functions. Ruby wraps
these C functions as Ruby methods. Even non-C Ruby implementations are likely to
call the functions in libc rather than implement the assembly themselves.

Thus, IO.pipe in Ruby is a wrapper for the [[shell:man%203%20pipe][pipe(3)]] C function which wraps the
[[shell:man%202%20pipe][pipe(2)]] system call. You might not have the [[shell:man%203%20pipe][pipe(3)]] manpage, since it's a very
thin wrapper for [[shell:man%202%20pipe][pipe(2)]], which has an equivalent manpage.
* *Avoiding* System Calls
The mode switch from user space to kernel space has more overhead and is slower
than a normal library function call[fn:11], thus user space can (and will often
attempt to) aggregate several user space calls into fewer system calls to avoid
the switching overhead.

This is a common concept in user space code, and Ruby is no excepton. This
aggregation does not happen transparently, so it should be understood and
explained to avoid confusion.
** I/O Buffering
As a Ruby programmer, you'll notice the IO class[fn:12] will buffer data you
write and you need to call "IO#flush" or set "IO#sync = true" to ensure other
processes can read it.

If you're a C programmer, you'll know the stdio library can do the same type of
buffering in user space. In fact, MRI 1.8 used the stdio library internally for
its user space buffering needs.

Kernel space may also implement its own buffering to avoid overhead when
interacting with the storage and network layers. This buffering can sometimes be
influenced from Ruby
** Memory Allocation
While Ruby programmers do not often worry about memory allocation, sometimes the
following question comes up:

#+begin_quote
Why did my Ruby process stay so big even after I've cleared all references to
big objects? I'm *sure* GC has run several times and freed my big objects and
I'm not leaking memory.
#+end_quote

A C programmer might ask the same question:

#+begin_quote
I free()-ed a lot of memory, why is my process still so big?
#+end_quote

Memory allocation to user space from the kernel is cheaper in large chunks, thus
user space avoids interaction with the kernel by doing more work itself.

User space libraries and runtimes implement a memory allocator[fn:13] which
takes large chunks of memory[fn:14] and divides them up into smaller pieces for
user space applications to use.

Thus, several user space memory allocations may occur before user space needs to
ask the kernel for more memory. Thus, f you got a large chunk of memory from the
kernel and are only using a small part of that, that large chunk of memory
remains allocated.

Releasing memory back to the kernel also has a cost. User space memory
allocators may privately hold onto that memory in the hope it can be reused
within the same process and not give it back to the kernel for use in other
processes.
* The Ruby IO Class
The IO class wraps file descriptors as Ruby objects and provides instance
methods which wrap system calls. Each IO object wraps one OS file
descriptor[fn:15]. IO also provides userspace buffering to avoid system calls
and utility methods to make a programmer's life easier.

C programmers may find the Ruby IO class analogous to the opaque "FILE" struct
in the stdio.

IO is often used via subclasses:

+ File is mostly intended for regular files
+ TCPSocket for TCP sockets
+ UNIXSocket for UNIX domain sockets
+ UDPSocket for UDP sockets
+ and so on


All of those classes are based on the IO class and wrap an integer file
descriptor.
** Layers of Buffering
There are at least four distinct layers of buffering within a machine.

Application buffers - what your application sees
Library buffers     - implemented by Ruby or libc
------------ kernel-userspace boundary ----------
Kernel software buffers
Kernel hardware buffers

Buffers may be implemented for both reading and writing.

The Ruby IO class can do the following:

+ accept application buffers from the user (IO#write)
+ return application buffers to the user (IO#read)
+ manage library buffers internally
+ copy (and remove) library buffers to kernel buffers
+ attempt to force kernel and hardware buffers to storage or network


A wider view of the above table would be:

process0    | process 1   | process 2
------------+-------------+------------
App buffers | App buffers | App buffers
Lib buffers | Lib buffers | Lib buffers
------kernel-user space boundary-------
Kernel software buffers
Hardware buffers

User space buffers are not shared between different processes in Ruby.

Kernel buffers are shared, allowing [[man%202%20read][read(2)]]-after-[[man%202%20write][write(2)]] consistency between
different processes. This is one of many ways for cooperating processes to share
data.

A few applcations[fn:16] may manage processe-shared buffers in user space, but
stock Ruby does not do this.

Library buffers (like most memory) in the Ruby IO class *are* shared between
different Threads and Fibers in Ruby.

Sharing of application buffers between Threads and Fibers is possible, but
usually not a good idea.

* The Unix Object Model (as seen in procfs)
Several filesystems have a procfs virtual filesystem mounted under [[file:/proc][/proc]],
although it doesn't seem to be standardized anywhere.

Among other things, procfs lets you see the relationship between process and
their file descriptors on the filesystem.

You can inspect which file descriptors a particular process is using by looking
in the "fd" subdirectory belonging to the PID of the process. For example, a
mutt process with PID 19245 and file descriptors 0, 1, 2, and 4 open would look
like this:

  /proc/19245/fd
  /proc/19245/fd/0
  /proc/19245/fd/1
  /proc/19245/fd/2
  /proc/19245/fd/4

Each PID has a directory in [[file:/proc][/proc]], and in each PID's directory there is an "fd"
folder.

Utilities like [[sh:man%201%20ps][ps(1)]] are likely to use information used in procfs to generate
their outpt. Other information in procfs is not consistent across
implementations, so consult your OS documentation for full details.

* Basic IO Methods
Consider C library functions (3) analogues, while the system call (2) functions
(3) are inevitably called by Ruby
** Opening and Closing Files
+ File.open :: [[shell:man%203%20fopen][fopen(3)]] which wraps [[shell:man%202%20open][open(2)]] and provides a File object
+ IO#close :: [[shell:man%203%20fclose][fclose(3)]], [[shell:man%202%20close][close(2)]] - Copies Ruby buffers to the kernel,
              invalidates the IO object and releases the file descriptor so it
              may be reused by the kernel.
** Some File Operations for Reading and Writing
+ IO#read :: [[man%203%20fread][fread(3)]] - read all specified bytes
+ IO#write :: [[shell:man%203%20fwrite][fwrite(3)]] - write all specified bytes
+ IO#sync, IO#sync= :: [[shell:man%203%20setvbuf][setvbuf(3)]] controls Ruby write buffering
+ IO#flush :: [[shell:man%204%20fflush][fflush(3)]] - copies existing Ruby write buffers to kernel
+ IO#syswrite :: [[shell:man%202%20write][write(2)]] - copies application buffers to kernel
+ IO#sysread :: [[shell:man%202%20read][copies kernel buffers to application]]


Setting IO#sync= to true will make IO#write copy application buffers directly
into kernel buffers, bypassing Ruby buffers. IO#sync does not influence read
buffering.

If IO#sync is false, IO#write may copy small application buffers into Ruby
buffers before doing IO#flush internally.

The non-sys* methods will retry until the operation is complete, or raise on any
errors. The sys* variants do not retry if the kernel returns a partial [[shell:man%202%20read][read(2)]]
or [[shell:man%202%20write][write(2)]], and will also raise on errors.

Mixing sys* and non-sys* methods is not recommended and will result in errors or
exceptions.

* Regular Files and Metadata
Regular files on a persistent filesystem are pointers or links to internal
metadata known as inodes. The implementation details of inodes varies between
various filesystems and is usually not the concern of user space. User space
developers should only need to know a few common traits about inodes
** device number (File::Stat#dev)
The device number is a unique integer identifier for the device an inode belongs
to. Each file system partition is considered its own "device", so a device
number does not necessarily correspond to a physical device.

A device number is unique within a running Unix system, no two "devices" may
have the same device number at the same time.
** inode number (File::Stat#ino)
The inode number is a unique integer identifier for an inode within a particular
device. Like PIDs, FDs, and device numbers, they are opaque pointers to complex
objects in kernel space.

The combination of device and inode number is required to uniquely identify any
inode (and thus file) in the system
** File Names
In many cases, there is a 1:1 relationship between file names and inodes. That
is, each file name points to its own inode, much like how one variable points to
one ruby object:

  ".bashrc" -> inode_number=123, device_number=456

It is important to know the file name -> inode relationship is one way. Inodes
do not know which file name(s) are pointing to them. Similarly, Ruby objects do
not know which variable name(s) are assigned to them.

When working with File objects, one should know that the File#path method return
value in Ruby is determined in user space with File.open is called, *not* when
File#path is called:

#+begin_src ruby
  file = File.open(".bashrc")
  file.path  # returns value or ".bashrc" determined above
#+end_src
** Creating Inodes and Files
Making the [[shell:man%202%20open][open(2)]] system call with the O_CREAT flag will create a file.

File.open can accept the equivalent IO::CREAT constant, or [[man%203%20fopen][fopen(3)]]-style mode
strings ("w", "a") to create an inode if the specified file name does not exist.

The Unix [[shell:man%201%20touch][touch(1)]] command and FileUtils.touch method both create files with
[[shell:man%202%20open][open(2)]] in this way. Historically there is also a [[shell:man%202%20creat][creat(2)]] system call for
creating and opening files, but [[shell:man%202%20open][open(2)]] is more flexible and preferred. Ruby
does not use nor expose [[man%202%20creat][creat(2)]] to the user.
** Hard Links
Since you should understand how two or more variables can point to the same
object in Ruby, you should be able to understand how two or more file names can
point to the same inode on one device.

Like two variables pointing to the same Ruby object, two or more links pointing
to the same inode are indistinguishable from each other. Hard links to existing
files are created with the File.link method, which makes the [[shell:man%202%20link][link(2)]] system
call. There is usually a system-dependent limit on the number of links to a
particular inode -- File.link will raise Errno::EMLINK if this limit is hit.
** Number of Hard Links (File::Stat#nlink)
While inodes do not know which file names point to it, inodes are aware of how
many file names point to it. Each time a hard link is created, the number of
hard links to the referenced inode is incremented.

File names may be removed with the [[man%202%20unlink][unlink(2)]] system call (via File.unlink in
Ruby). Unlinking a file will decrement the number of links an inode has. It is
possible for an inode to have zero links to it and still be valid.
** File::Stat
File::Stat is the Ruby class used to present inode information to the user. All
of the fields mentioned above are available from a File::Stat object.

File::Stat is a wrapper for the [[shell:man%202%20stat][stat(2)]] system call and returns a File::Stat
object for a given path.

If you have a Ruby IO object open, you can use IO#stat to get the File::Stat
object for the file descriptor belonging to the IO/File object. IO#Stat makes
the [[shell:man%202%20fstat][fstat(2)]] system call instead of [[shell:man%202%20stat][stat(2)]].

File::Stat is the Ruby equivalent/wrapper of the "struct stat" seen by C programmers.
* An Introduction to the Unix Pipe
The Unix pipe is an example of an anonymous file. Unlike regular files and
directories, anonymous files do not exist on the filesystem and do not persist
across reboots. Only the process that creates the anonymous file (and its
descendants) can access anonymous files. Anonymous files only persist until the
last process using it closes it.

At its heart, the Unix pipe is just like a pipe in plumbing: a one-way buffer
for transporting ayload from one end to another.

It is implemented as a circular ring buffer in the kernel:

#+begin_example
     user space | kernel space
----------------|--------------------------
data in --> fd[writer] ->- file[writer] -->\
                | \        |
                | [buffer] |
                | /        |
data out <-- fd[reader] -<- file[reader] <--/
#+end_example

The buffer is created by the [[shell:man%202%20pipe][pipe(2)]] system call and persists until both files
are closed. In Ruby, the IO.pipe method calls [[shell:man%202%20pipe][pipe(2)]] and returns an array of
two Ruby IO objects, a reader and writer:

#+begin_src ruby
reader, writer = IO.pipe # kernel creates internal buffer
#+end_src

Writing can be accomplished by making the [[shell:man%202%20write][write(2)]] syscall, the writer IO object
should default to IO#sync=true at creation.

#+begin_src ruby
writer.write("HELLO")
#+end_src

Reading can be accomplished by making the [[shell:man%202%20read][read(2)]] syscall.

#+begin_src ruby
reader.read(5) # => "HELLO"
#+end_src

Finally, the kernel memory for the buffer is released after both file objects
(through file descriptors and IO) are closed:

#+begin_src ruby
writer.close
reader.close
# kernel frees the buffer
#+end_src

As with regular files, pipes operate on byte streams and leave higher-level
functionality like encoding to user sspace.

Pipes also have important atomicity requirements standardized by POSIX. Given
the importance of pipes in Unix programming, we will revisit and give pipes much
more coverage in the future.
* Directories on the Filesystem
Directories are containers for files in addition to being files. Similarly, Ruby
Hashes are containers for Objects in addition to being objects.

The contents of the "/home/johndoe/" directory could be expressed as the
following Ruby pseudocode:

#+begin_src ruby
  root = {
    "home" => {
      "johndoe" => {
        ".bashrc" => Inode[123],
        ".vimrc" => Inode[456],
        ".mutt" => {
          ".muttrc" => Inode[789]
        }
      }
    }
  }
#+end_src

It's impossible for two identical file names to appear in the same directory at
the same time.
** Directory Entries
As hashes are composed of key-value pairs, directories are composed of directory
entries, or "dirent" structures which store file names and inode numbers. Like
"struct stat" information, the "struct dirent" exposed to user space contains
only the standardized, common information for user space, not the actual,
private information in the kernel or file system.

Ruby does not expose the dirent structure in any way (the standard C library
does), but one could express the dirent structure with the following Ruby
Struct:

#+begin_src ruby
  Dirent = Struct.new(:d_name, :d_ino)
  Dirent.new(".bashrc", 123)
#+end_src
** Reading Dirents
The Ruby Dir class handles reading directories, but only exposes names to the
user.

There are no portable syscalls for reading dirents from a directory, only
standardized *library* functions such as [[shell:man%203%20readdir][readdir(3)]] and [[shell:man%203%20readdir_r][readdir_r(3)]]. These
library functions are wrappers for non-portable system calls.

Furthermore, common functionality like partial name matching (globbing) is
handled by user space. Proper Unix file systems have no notion of encoding or
case-sensitivity in kernel space, thus inexact name matching rules need to be
applied in user space.

Sorting is also done in user space. The standard C library functions never
guarantee entries are returned in any particular order. This behavior matches
the behavior of Hashes in Ruby 1.8 and earler. In fact, some file systems store
or index name-to-inode mappings in a hash structure on disk.

All dentries (except "..") within one directory belong to the same device, and
often the same physical device[fn:17], so only the inode number is stored in the
dirent.
** Creating and Removing Directories
Creating directories requires the [[shell:man%202%20mkdir][mkdir(2)]] syscall provided by the Ruby
Dir.mkdir method.

Once created, it is possible to use [[shell:man%202%20open][open(2)]] to "open" a directory like a regular
file and IO#stat it.

The [[shell:man%202%20rmdir][rmdir(2)]] syscall is used to remove directories, and is provided by Dir.rmdir
in Ruby.

High-level wrappers like FileUtils.mkpath (or "[[shell:man%201%20mkdir][mkdir(1)]] -p") and
FileUtils.rmtree (or "[[man%201%20rm][rm(1)]] -r") need to invoke the appropriate syscall for
every entry they wish to create or remove.

On modern Unicies, it is not possible to create hard links for
directories. Allowing directoriy hard links would lead to infinite recursion
loops when traversing directories.

Thus, the File::Stat#nlink field for directories shows the number of entries the
directory contains.
** "." and ".." entries
Every directory contains an entry for itself, ".", and to its parent, "..".

The root "/" directory is specal and is its own parent.
** [[man%202%20rename][rename(2)]]
The File.rename method wraps the [[shell:man%202%20rename][rename(2)]] syscall to change the name of a file
within the same device. [[man%202%20rename][rename(2)]] can occur within the same or different
directories as long as the source and destination exist on the same device.

For regular files:

#+begin_src ruby
File.rename("foo", "bar")
#+end_src

Is roughly equivalent to:

#+begin_src ruby
File.link("foo", "bar")
File.unlink("foo")
#+end_src

However, it is impossible (on a POSIX-compliant filesystem) for userspace to
access both "foo" and "bar" at the same time when using
File.rename. Additionally, File.rename will work on directories whereas
File.link and File.unlink do not work on directories.

Commands like [[man%201%20mv][mv(1)]] will use [[shell:man%202%20rename][rename(2)]] if both the source and destination exist
on the same device. This makes [[man%201%20mv][mv(1)]] very fast in cases where it works on the
same device, but slow and non-atomic if the source and destination need to cross
devices.

* Unix Time and the Ruby Time Class
The Unix epoch is defined as January 1, 1970, 00:00:00 UTC (Coordinated
Universal Time[fn:18]). Unix systems return the time in seconds as a signed
integer relative to the Unix epoch. Negative numbers are interpreted as dates
before the Unix epoch.

Using seconds (and fractions of a second) to represent time allows application
authors to rely on arithmetic rather than specialized functions for calculating
time intervals.

File systems expose timestamps for all files in Unix time with varying degrees
of accuracy and granularity. The Ruby File and File::Stat classes can support
timestamps with sub-second granularity on some systems.

Modern kernels do not know nor care about timezones. Conversions from UTC to the
local timezone (and vice versa) are done in user space[fn:19]. Different
processes running concurrently on the same machine do not necessarily share the
same local timezone.
** Ruby Time Class
The Ruby Time class includes methods for reading the system time and allows
converting from an integer (seconds since the epoch) to a Ruby Time object.

Ruby Time objects have a timezone attached to them, but this is a user space
construct.
*** Time.now / [[shell:man%202%20gettimeofday][gettimeofday(2)]] / [[shell:man%202%20clock_gettime][clock_gettime(2)]]
[[shell:man%202%20gettimeofday][gettimeofday(2)]] is the commonly available system call for reading the Unix time
with up to millisecond resoluton. On some systems, [[shell:man%202%20clock_gettime][clock_gettime(2)]] may be used
for nanosecond resolution[fn:20].

Time.now will return the current time as a Time object, taking into account the
timezone of the current process in user sace. Ruby 1.9 may use [[shell:man%202%20clock_gettime][clock_gettime(2)]]
internally if available, but fall back to [[shell:man%202%20gettimeofday][gettimeofday(2)]] to retrieve the system time.
*** Time#tv_sec / Time#tv_usec / Time#tv_nsec
These accessors allow access to the underlying values returned by
[[shell:man%202%20gettimeofday][gettimeofday(2)]] or [[shell:man%202%20clock_gettime][clock_gettime(2)]] as integers. For systems without nanosecond
resolution, Time#tv_nsec may just be the value of Time#tv_usec multiplied
by 1000.
*** Time.at - converts from Unix time to a Time object
If you have the number of seconds (and maybe microseconds) as an integer since
the Unix epoch, you can convert that into a Ruby Time object using the Time.at
class method:

#+begin_src ruby
Time.at(seconds[, microseconds])
#+end_src

This is useful if you encounter a Unix timestamp anywhere but want to have a
Ruby Time object. The local timezone is attached to the created object.

There is no underlying syscall needed for this, this conversion can be performed
entirely in user space, although it may require memory allocation
*** Processs Timezone
The "TZ" environment variable controls the timezone for a given processs, and
thus the timezone attached to a Ruby Time object. If "TZ" is unset, the timezone
of the process is implementation-defined.
*** Time#utc
If your process is not running under UTC, you may wish to convert Time objects
to UTC with this method.
** Setting System Time
Ruby does not provide methods to change the system time. Changing system time
typically requires administrator privileges, and few applications need to change
the system time. For machines with network access, system time is commonly
synchronized via NTP and gradually adjusted via [[man%203%20adjtime][adjtime(3)]] and / or non-portable
syscalls.
** Monotonic Clocks
Some systems support a monotonic clock which is not adjustable (even by the
administrator). A monotonic clock is useful for maintaining consistent timing
and scheduling across system time changes.

Ruby currently (as of 1.9.3) does not provide access to the monotonic
clock. However, Ruby implementations may use the monotonic clock internally for
timing (via [[man%202%20clock_gettime][clock_gettime(2)]]) and recording time differences.
** Avoiding System Calls
You may notice that the lack of [[man%202%20gettimeofday][gettimeofday(2)]] or [[shell:man%202%20clock_gettime][clock_gettime(2)]] syscalls if
you're tracing syscalls. This is because C libraries can work with the kernel to
optimize away the syscalls for [[shell:man%202%20gettimeofday][gettimeofday(2)]] and [[shell:man%202%20clock_gettime][clock_gettime(2)]]. These
implementations may trade accuracy for speed, but may be disabled by the
administrator if accuracy is more important than speed.
* IO#dup and the [[shell:man%202%20dup][dup(2)]] system call
IO#dup is Object#dup in Ruby: it creates a shallow copy of an existing
object. To create a shallow copy, the IO#initialize_copy callback method
performs the [[shell:man%202%20dup][dup(2)]] syscall on the underlying file descriptor the IO object
wraps.

Like Object#dup in Ruby, [[shell:man%202%20dup][dup(2)]] is a shallow clone that does not copy the
underlying open file object in the kernel, but creates a new reference to an
existing kernel object.

Thus, two (or more) file descriptors in the same process can refer to the same
open file in the kernel.

Before calling IO#dup, we have a 1:1:1 relationship:

+ one Ruby IO object
+ one file descriptor
+ one open file object in the kernel


After we call IO#dup, we have a 2:2:1 relationship:

+ two Ruby IO objects
+ two file descriptors
+ one file object in the kernel


IO#dup can be called on the same IO object any number of times, so there may be
an N:N:1 relationship as long as the process (and system) resource limits are
not exceeded.

Most kernel-level (but not user space) changes to one IO object are immediately
visible in the IO object(s) it was copied from (or copied to).
** Effect on IPC
IO#deup means IO#close / [[shell:man%202%20close][close(2)]] will only remove a *reference* to the file
object in the kernel. Only when the last file descriptor for a given file object
is closed is the actual file object closed and released in the kernel.

For applications relying on receiving an end-of-file condition (from a socket or
pipe), IO#dup[fn:21] can (sometimes inadvertantly) prevent the end-of-file
condition from being reached in the reader.
* Unix Processes and their Attributes
Processes are kernel objects that run user space code. As we've established
before, each Unix process is identified by an integer process identifier (PID)
and has a file descriptor table.
** PIDs
Each process knows two PIDs: its own and its parent's (PPID).

Process.pid and $$ are wrappers for the [[shell:man%202%20getpid][getpid(2)]] syscall and Process.ppid is a
wrapper for [[shell:man%202%20getppid][getppid(2)]]. While the PID of a process never changes, its PPID may change.
** $0 / $PROGRAM_NAME
Each process has a name. This variable may be reassigned to change the name of
this process in the output of tools like [[shell:man%201%20ps][ps(1)]].

Ruby does not expose $EXECUTABLE_NAME ($^X) like Perl does, however
$PROGRAM_NAME is set to the executable name for Ruby programs at startup.
** ARGV
This is an Array of command-line arguments given to a process =ARGV[0]= in Ruby is
the first argument given to the executable, not the executable name, unlike in
languages like C where it is the name of the executable.

Modifying this array will not affect the name of the process in tools like
[[shell:man%201%20ps][ps(1)]]. Command-line option parsing libraries like 'optparse' and 'getoptlong' in
the Ruby standard library may modify ARGV.
** Signal mask/handlers
Ruby implementations have internal system-level signal handlers that may later
dispatch Ruby code (registered via Signal.trap). Signal handlers written in Ruby
are not subject to the limitations of system-level signal handlers.
** ENV
This Hash-like object holds process environment variables. Environment variables
are global to the process and are used to share information with system
libraries and child processes in a language-independent manner.

Null-terminated C strings are mapped to Ruby Strings in both the keys and values
of this Hash-like object.

While the system environment appears Hash-like, it is not exposed to user space
so it does not have the same performance or algorithmic complexity as a Ruby Hash.
** Working Directory (Dir.pwd, Dir.chdir)
All processes have a working directory that they run in.
** Process.times
Each process keeps track of CPU time spent in user space and the system (kernel)
as well as the accumelated times of its children.

Process.times is used to implement the Benchmark module in the Rby standard library.
** Usage counters ([[shell:man%202%20getrusage][getrusage(2)]])
Unfortunately, there is no Ruby api for [[shell:man%202%20getrusage][getrusage(2)]]. Some GC implementations
may se it to provide profiling statistics
** Process.getrlimit / Process.setrlimit
These get and set process resource limits such as the maximum number of open
file descriptors, resident set size, niceness, CPU time, etc.

They are wrappers for the respective [[shell:man%202%20getrlimit][getrlimit(2)]] and [[shell:man%202%20setrlimit][setrlimit(2)]] syscalls.
** User IDs / Group IDs
Each process has a real, effective, and saved UID and GIDs.

Process::UID.change_privilege and Process::GID.change_privilege are the most
portable and easiest ways to change the UID(s) and GID(s) of a process.
** umask (File.umask)
The umask is the file mode creation mask of the process. This governs the
filesystem permissions of newly-created files (File.open) and directories (Dir.mkdir).
* Unix signals - primitive interprocess communication
Signals are the most basic way for processes to communicate with each
other on a Unix system.  Each process has signal handlers configured
by default, so some actions (e.g. killing a process) are always
available.

There are two distinct classes of signals defined by POSIX:

+ standard
+ real-time

Currently, Ruby implementations (that I'm aware of) only deal with
standard signals.  Ruby implementations also control the signal
mask and will temporarily block/unblock signals to perform critical
operations in the interest of (portable) thread/async-safety.

Operating systems have a pre-defined list of signals.  This list of
signals is available for all processes to send and receive.  Each signal
has a human-readable name (e.g.  "KILL" or "SIGKILL") and non-negative
number (e.g. 9) associated with it.  To see which ones are supported by
both Ruby and your OS, the =Signal.list= method returns a =Hash= mapping
their names to respective signal numbers.

Some signals (e.g. SEGV, VTALRM) may be reserved by the Ruby
implementation for internal use.  Other signals (STOP, KILL) may
not be blocked, ignored, or handled at all by any userspace process.

Signals may be assigned (and reassigned) handler functions (aka
"callbacks") which execute upon delivery of a signal.  Those of you
familiar with event-driven programming models will realize signals are
another type of event (not much unlike I/O) which you may define
callbacks for.

However, writing signal handlers requires more care and attention than
"normal" code in your application.  The universal wisdom is to keep
signal handlers simple and short, regardless of the programming language
you're writing in.

While Ruby helps users avoid many of the low-level details and caveats
of implementing signal handling, there are still pitfalls to be
aware of and avoid.


** Methods for working with signals in Ruby

=Process.kill= maps to the [[shell:man%202%20kill][kill(2)]]/[[shell:man%202%20killpg][killpg(2)]] system calls for sending
signals to processes or process groups.  =Signal.trap= (=Kernel#trap=)
is analogous (but not directly mapped to [[shell:man%202%20sigaction][sigaction(2)]] (or [[man%202%20signal][signal(2)]]).

Read more about them via ri or rdoc.

* Implementing signal handlers - some caveats
** Signal handlers may run at any time

If your program receives a signal, Ruby will invoke the associated
signal handler as soon as it is able to.  This means a signal handler
can hijack your existing code flow just about anywhere in your program
(including inside methods of any libraries you use).  Normal code
execution resumes once the signal handler finishes execution.

This is a big difference from most event-driven programming frameworks
where callbacks for a given object/event fire synchronously and will not
step over existing code flow.


** Reentrancy vs thread-safety

While reentrancy and thread-safety are related concepts, it is
absolutely critical to understand is they are NOT the same, and one does
not imply the other.

(There are existing articles on this, so I won't dive into this more)


** Signal handlers must be reentrant

When writing a signal handler, you must ask yourself:

What happens when another signal arrives while this handler is
still running?

Since signal handlers are invoked as soon as possible, they can even run
while another (or the same) signal handler is running.  Thus signal
handlers must be able to tolerate reentrancy.

Back to thread-safety: some constructs required for thread-safety fail
horribly when used in situations that require reentrancy.  Most mutex
implementations (including the Ruby Mutex class) deadlock when used
inside a signal handler.

Consider the following snippet:

#+begin_src ruby
lock = Mutex.new

# XXX this is an example of what NOT to do inside a signal handler:
trap(:USR1) do
  lock.synchronize do
    # if a second SIGUSR1 arrives here, this block of code
    # will fire again.   Attempting Mutex#synchronize twice
    # the same thread leads to a deadlock error
  end
end
#+end_src

Thus, you must ensure any code you use inside a signal handler is
reentrant-safe.  Even using the =Logger= class in the Ruby standard
library (which can call =Mutex#synchronize=) can deadlock inside a signal
handler.


** Signal reliability

Signals are not completely reliable in Ruby (nor many applications, for
that matter).  If multiple, identical signals are received in a short
time frame, you're guaranteed to fire a handler for /at least/ one of
the signals, but not all of the signals received.

This is because Ruby implementations must[fn:22] block signals from firing
while manipulating internal data structures.  When normal signals get
blocked, they do not queue up in the OS kernel and instead only get a
boolean bit set.


** Untrappable, unblockable signals

Regardless of the Ruby runtime state, =SIGSTOP= still suspend a process
immediately (until =SIGCONT= is received), and cannot be trapped by the
Ruby runtime (or any userspace process).

Similarly, =SIGKILL= terminates a process immediately.  Processes are are
given no chance to stop or react to them.  Thus, no blocks registered
via =Kernel#at_exit=, =END=, nor object finalizers can run upon =SIGKILL=.

Sending "Ctrl-Z" from a terminal generates =SIGTSTP=, not =SIGSTOP=,
and =SIGTSTP= is trappable.


** Deferred signal handling

POSIX defines a very small number of C functions that are safe to use
inside a signal handler[fn:23].  As Ruby programmers have little direct
control over which C functions they end up calling, Ruby implementations
(at least modern ones) implement deferred signal handling.

Thus Ruby implementations register trap signals using C functions (via
[[shell:man%202%20sigaction][sigaction(2)]]) and dispatch Ruby signal handlers out when the
VM/interpreter is in a safe state.

Modern versions of Perl (and presumably other high-level languages)
also use deferred signal handling.

Even with deferred signal handling implemented by the language runtime,
it is still a good idea to _also_ implement deferred signal handling
in your Ruby applications to avoid the same reentrancy pitfalls.
* handling excessive CPU usage within a process
If you've ever had issues with a runaway process eating up CPU time and
want to kill it automatically, it's possible to use
=Process.{get,set}rlimit= and a signal handler for =SIGXCPU= to accomplish
this.

The following snippet of code implements an example of a CPU limiter.
This self-contained example aborts itself once CPU utilization
reaches 50%.

#+begin_src ruby
# Users of older Rubies may want to use Process::RLIMIT_CPU
# instead of :CPU in this code.

soft, hard = Process.getrlimit(:CPU)
last_update = Time.now
max_cpu_time = 5

# this signal handler runs once we've hit max_cpu_time:
trap(:XCPU) do

  # Calculate CPU utilization based on elapsed (wall clock) time
  # and max_cpu_time
  elapsed = Time.now - last_update
  cpu_usage = max_cpu_time / elapsed
  puts "CPU utilization: #{"%0.2f" % (cpu_usage * 100)}"
  if cpu_usage > 0.5 # 50%
    abort "CPU utilization exceeded 50%"
  end

  # If we're below our CPU usage threshold, install a new limit based on
  # current Process.times
  last_update = Time.now
  t = Process.times
  Process.setrlimit(:CPU, max_cpu_time + t.utime.round + t.stime.round, hard)

  # We now return to our regularly scheduled looping ...
end


# Install an initial limit for max_cpu_time using existing process times
t = Process.times
Process.setrlimit(:CPU, max_cpu_time + t.utime.round + t.stime.round, hard)

# The signal handler registered for :XCPU will run automatically
# after the CPU time hits max_cpu_time seconds
loop do
  # do something to use the CPU...
  100000.times { 1 + 1 }

  # you can change the amount of time slept to influence CPU utilization
  sleep 0.01
end
#+end_src


I learned this example a few years ago from reading the PulseAudio
source code:

#+begin_example
$ git clone git://git.0pointer.de/pulseaudio
$ $EDITOR src/daemon/cpulimit.c
#+end_example
** License
This section is not covered by the GPL3, it is CC0: To the extent possible under
law, Eric Wong has waived all copyright and related or neighboring rights to the
contents of this section.



* Footnotes

[fn:1] or more

[fn:2] however, "POSIX-compliant" does not guarantee a system is Unix or even
"Unix-like". Old Unix systems are not "POSIX-compliant" either.

[fn:3] This is *not* the Kernel#system method in ruby, nor the corresponding C
library [[shell:man%203%20system][system(3)]] function! In fact, the ruby module "Kernel" has little to do
with operating system kernels.

[fn:4] as in beer and in speech

[fn:5] although experimental Multi-VM implementations exist that allow multiple
Ruby VMs within a single process

[fn:6] even for non-storage tasks

[fn:7] the intended successor to Unix

[fn:8] among others

[fn:9] including pseudo

[fn:10] libc

[fn:11] explaining why this is so expensve is left as an exercise for the reader

[fn:12] and subclasses like File

[fn:13] e.g.: [[shell:man%203%20malloc][malloc(3)]] in libc

[fn:14] via [[shell:man%202%20brk][brk(2)]], [[shell:man%202%20sbrk][sbrk(2)]], [[shell:man%202%20mmap][mmap(2)]], or various non-portable methods.

[fn:15] Multiple IO objects may wrap a sngle file descriptor, but that can be a
bad idea.

[fn:16] database servers like PostGreSQL come to mind

[fn:17] There exists some union filesystems which break this assumption, however
they are uncommon and often restricted to read-only access.

[fn:18] One should know UTC is not exactly the same as Greenwich Mean Time (GMT)

[fn:19] Timezone information is usually on (regular) files, so it may require
syscalls to read those files.

[fn:20] You're not guaranteed that this level of accuracy is supported by your
kernel or your hardware. Consult your OS and hardware documentation for more
information.

[fn:21] and similar functions, like fork

[fn:22] back to reentrancy, temporarily blocking signals to ensure
reentrant-safe data manipulation is analogous to using a
mutex lock to accomplish thread-safe data manipulation.

[fn:23] Linux [[shell:man%207%20signal][signal(7)]] manpage is one place that lists these functions
