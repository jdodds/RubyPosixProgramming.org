* License:
[[http://www.gnu.org/licenses/gpl-3.0.txt][GPLv3]] (or later, at the discretion of Eric Wong)
* Prerequisite Knowledge / Conventions used
** Prerequisite Knowledge
+ You should know basic Ruby syntax.
+ Bourne shell knowledge will be useful, but not required.
+ You do not need to know C, though it will be referred to and Ruby methods will
  be mapped to corresponding or analogous C functions.
+ You must know that two[fn:1] variables in Ruby can refer to the same
  object. This concept is present in Unix, so it is *very* important to
  understand the following:

  #+begin_src ruby
    a = "this is a string"
    b = a    # 'b' refers to the same String object
    a << "!" # modifies the String object 'a' points to

    "this is a string!" == a

    # You should understand why the following statements are true:
    "this is a string!" == b
    "this is a string" != b
  #+end_src
** Notations / Conventions
*** Ruby method documentation references
should be the same as Ruby documentation

+ IO.pipe :: class/singleton method
+ IO#stat :: instance method
*** C function documentation references

+ pipe(2) :: "#{function_name}(#{section})"
             The C function manpage can be accessed as:
               man #{section} #{function_name}
             so [[shell:man%202%20pipe][man 2 pipe]] for pipe(2)
* A Fluffy Introduction to Unix Systems Programmng in Ruby
** What is Unix?
Unix is an operating system originally developed at Bell Labs n 1969. Numerous
versions and clones ("Unix-like" systems) have been released over the decades as
the Unix family continues to evolve. Nowadays, POSIX is the set of standards
that attempt to define the interfaces of Unix and Unix-like systems[fn:2].

Modern Unix systems have two distinct software layers, user space and kernel
space, which layer like so:

User space   (user applications, where Ruby runs)
--------------------------------------------------
Kernel space (schedulers, sockets, pipes, VFS ...)
--------------------------------------------------
Hardware     (disks, network cards, memory)

The kernel acts as a mediator for user space and the underlying hardware.
** What is Unix systems programmng?
Unix and Unix-like operating systems share a set of common programming
interfaces for user space to interact with the kernel, and in turn
hardware. These interfaces are referred to as "system calls"[fn:3] or
"syscalls".

We'll be interacting with Unix and Unix-like operating systems using the Ruby
programming language.

Unix systems programming is often thought of as "plumbing" as it deals with
basic infrastructure and data flow in and out of the system.
** Why Unix?
Unix and Unix-like systems are everywhere. From traditional deployments on
workstations and servers, to smartphones and tablets, Unix and its clones have
become pervasive in the world of computing over the past four decades and are
showing no sign of decline.

Many implementations of Unix and its clones are free[fn:4], so it's readily
available for anybody with the time and will to study.

The design of Unix is minimalist and simple. While there have been undeniable
missteps and embarassing mistakes over the years, its systems programming
interface remains absolutely consistent and straightforward.
** Why systems programming?
Knowledge of systems programming is often useful for understanding,
troubleshooting and debugging problems in high-level applications. *Lack* of
systems programming knowledge and understanding can cause problems in both the
design and implementation of applications.

Unix systems programming knowledge transcends programming languages. As long as
an application runs on a Unix-like system, Unix systems programming knowledge
will be useful for implementing, improving, and troubleshooting applications.
** Why Ruby?
Traditionally, Unix systems programming is taught in C, but high-level languages
like Perl, Python and Ruby can access most of the same Unix APIs available to C
programmers.

Unlike C, Ruby is a very forgiving language. There is no pointer manipulation
and no manual memory management. The Rubyist does not need to worry about many
common bugs found in C code.

Error handling is also enforced in Ruby. While C programmers should check for
errors on every syscall, Rubyists have SystemCallExceptions(Errno::*) thrown in
their face when errors are encountered.

As far as the author knows, there is little documentation on Unix systems
programming in Ruby (or languages other than C for that matter). Given the
prevalance of programmers working in high-level languages that do not know C,
Unix systems programming knowledge may have been off limits to many.

* The Unix Object Model (as seen from user space)
A running Unix/Unix-like kernel exposes two primary types of object to
userspace, Processes and Open Files.
** Processes
Processes are instances of running applications. Ruby programs typically run as
their own process[fn:5] in userspace.

Kernels expose a Process IDentfier (PID) as positive integers to userspace
programs so they can be uniquely identified. Each PID represents one (private)
process object in the kernel. The PID is just a reference or ponter to that
object. Two running processes cannot have the same PID, and two PIDs cannot
refer to the same process, but PIDs can be recycled and reused over time.

PIDs are global in scope to each running Unix system.

Processes are created from their parent using the [[shell:man%202%20fork][fork(2)]] system call. Ruby
wraps this method in Kernel#fork.
** Open Files
Running processes may create, open, and release objects known as "files" in
kernel space usng the APIs provided in user space. Much of Unix systems
programmng revolves around manipulating "file" objects of various types.

The kernel exposes non-negative integers known as "file descriptors" to
userspace. These are similar to PIDs as they are integers which point to objects
within the kernel.

One of the design goals of Unix was "everything is a file", and indeed each file
descriptor may refer to one of several types of objects within a running
kernel. All of these objects can be called "files" regardless of them being
stored on hard disks or visible on the filesystem.

File descripters may be reused and recycled within the lifetime of a
process. They are more frequently recycled than PIDs.

Each process has its own file descriptor table, inherited from its parent.

Unlike PIDs, several file descriptors may refer to the same file object inside
the kernel.

File descriptors have properties of their own that are not tied to the
underlying file object in the kernel.

Open files are the primary interface for processes to interact with the kernel.
** Summary
Processes are containers for open files, among other thngs. Open files are
objects in the Unix kernel that can be accessed from within processes.
* An Overview of the Unix Filesystem
Unix has a heirarchical filesystem visible to all running processes, and it is
the primary shared namespace within a Unix system.

The top (or root) of this namespace starts at "/", and subdirectories may be
created under it, each path component separated by "/".

Filesystems may contain other filesystems. The root filesystem on a modern Unix
almost always contans other filesystems.

Filesystems may have several types of files:

+ directories
+ symlinks
+ UNIX domain sockets
+ FIFOs
+ character devices
+ block devices
+ "regular" files


Traditional filesystems are backed by stable storage (hard drives, SSD) and
persist across reboots and shutdowns. Some of these are designed for Unix and
are considered POSIX-compliant, while others were designed for other OSes and
are incompatible with POSIX to various degrees.

Various pseudo-filesystems exist, but they are mostly non-standardized. Among
pseudo-filesystems, there are:

+ memory-only filesystems
+ network filesystems
+ proc (process information) filesystems
+ device filesystems
+ filesystems for tuning/inspecting the kernel and hardware


Pseudo-filesystems allow Unix-based OSes to avoid implementng system calls only
useful within a limited scope.

The "everything-is-a-file" design and use of filesystems[fn:6] allows a few
system calls to be useful for multiple purposes. This consistency improves the
user experience by reducing the amount a systems programmer needs to know, and
also improving the discoverability of the interfaces.

As the amount of system calls is relatively small, learning Unix systems
programming should be easier than in other operating systems.

Plan 9[fn:7] takes "everything-is-a-file" more literally to further minimize the
need for specialized system calls. This Plan 9 idea[fn:8] is being co-opted into
existing userspaces and operating systems.

* Traditional Unix Filesystem Behavior
POSIX-compliant filesystems are the standard, other[fn:9] filesystems attempt to
expose a user-interface simlar to those in POSIX-compliant
filesystems. Unfortunately, this means there are sometimes leaky, incompatible,
and even dangerous abstractions that may be present.

Unix filesystems are byte-oriented. They have no notion of encodings, and thus
cannot be case-insensitive. They do not normalize path names or data in any
way. The lack of conversion and normalization makes path lookup operations fast.

In a path name, only the "\0" byte is disallowed. The "/" byte is used to
delimit directores, so it may not exist in a path component itself. Otherwise,
path names may contain any other value.

Regular files will store any bnary data stream without altering it in the
kernel. Filesystem operations have no notion of "lines" and won't convert CRLF
line endings to LF or vice-versa.

There are many filesystem operations defned to be atomic in POSIX. These are
ideal for helping multiple processes interact with each other
safely. Unfortunately, they also make POSIX-compliance difficult for
implementations of network and distributed filesystems.
* System Calls in Unix
Syscalls are the interface that user space uses to interact with kernel
space. When a user space application makes a syscall, it's telling the kernel to
execute code on its behalf.

Ruby provides a global "syscall" method on many platforms. It's useful for
learning and experimentation, but not recommended for general use as it is
fragile and non-portable. There is usually no need to use this method as many
useful syscalls are already provided and wrapped by Ruby methods.

For a user space application to make a system call, architechture and
OS-dependent code must be invoked. At the lowest userspace levels, this is
implemented in non-portable assembly code.

Fortunately, most system calls are already provided as wrappers by the system C
library[fn:10] so they appear to user space as portable C functions. Ruby wraps
these C functions as Ruby methods. Even non-C Ruby implementations are likely to
call the functions in libc rather than implement the assembly themselves.

Thus, IO.pipe in Ruby is a wrapper for the [[shell:man%203%20pipe][pipe(3)]] C function which wraps the
[[shell:man%202%20pipe][pipe(2)]] system call. You might not have the [[shell:man%203%20pipe][pipe(3)]] manpage, since it's a very
thin wrapper for [[shell:man%202%20pipe][pipe(2)]], which has an equivalent manpage.
* *Avoiding* System Calls
The mode switch from user space to kernel space has more overhead and is slower
than a normal library function call[fn:11], thus user space can (and will often
attempt to) aggregate several user space calls into fewer system calls to avoid
the switching overhead.

This is a common concept in user space code, and Ruby is no excepton. This
aggregation does not happen transparently, so it should be understood and
explained to avoid confusion.
** I/O Buffering
As a Ruby programmer, you'll notice the IO class[fn:12] will buffer data you
write and you need to call "IO#flush" or set "IO#sync = true" to ensure other
processes can read it.

If you're a C programmer, you'll know the stdio library can do the same type of
buffering in user space. In fact, MRI 1.8 used the stdio library internally for
its user space buffering needs.

Kernel space may also implement its own buffering to avoid overhead when
interacting with the storage and network layers. This buffering can sometimes be
influenced from Ruby
** Memory Allocation
While Ruby programmers do not often worry about memory allocation, sometimes the
following question comes up:

#+begin_quote
Why did my Ruby process stay so big even after I've cleared all references to
big objects? I'm *sure* GC has run several times and freed my big objects and
I'm not leaking memory.
#+end_quote

A C programmer might ask the same question:

#+begin_quote
I free()-ed a lot of memory, why is my process still so big?
#+end_quote

Memory allocation to user space from the kernel is cheaper in large chunks, thus
user space avoids interaction with the kernel by doing more work itself.

User space libraries and runtimes implement a memory allocator[fn:13] which
takes large chunks of memory[fn:14] and divides them up into smaller pieces for
user space applications to use.

Thus, several user space memory allocations may occur before user space needs to
ask the kernel for more memory. Thus, f you got a large chunk of memory from the
kernel and are only using a small part of that, that large chunk of memory
remains allocated.

Releasing memory back to the kernel also has a cost. User space memory
allocators may privately hold onto that memory in the hope it can be reused
within the same process and not give it back to the kernel for use in other
processes.
* The Ruby IO Class
The IO class wraps file descriptors as Ruby objects and provides instance
methods which wrap system calls. Each IO object wraps one OS file
descriptor[fn:15]. IO also provides userspace buffering to avoid system calls
and utility methods to make a programmer's life easier.

C programmers may find the Ruby IO class analogous to the opaque "FILE" struct
in the stdio.

IO is often used via subclasses:

+ File is mostly intended for regular files
+ TCPSocket for TCP sockets
+ UNIXSocket for UNIX domain sockets
+ UDPSocket for UDP sockets
+ and so on


All of those classes are based on the IO class and wrap an integer file
descriptor.
** Layers of Buffering
There are at least four distinct layers of buffering within a machine.

Application buffers - what your application sees
Library buffers     - implemented by Ruby or libc
------------ kernel-userspace boundary ----------
Kernel software buffers
Kernel hardware buffers

Buffers may be implemented for both reading and writing.

The Ruby IO class can do the following:

+ accept application buffers from the user (IO#write)
+ return application buffers to the user (IO#read)
+ manage library buffers internally
+ copy (and remove) library buffers to kernel buffers
+ attempt to force kernel and hardware buffers to storage or network


A wider view of the above table would be:

process0    | process 1   | process 2
------------+-------------+------------
App buffers | App buffers | App buffers
Lib buffers | Lib buffers | Lib buffers
------kernel-user space boundary-------
Kernel software buffers
Hardware buffers

User space buffers are not shared between different processes in Ruby.

Kernel buffers are shared, allowing [[man%202%20read][read(2)]]-after-[[man%202%20write][write(2)]] consistency between
different processes. This is one of many ways for cooperating processes to share
data.

A few applcations[fn:16] may manage processe-shared buffers in user space, but
stock Ruby does not do this.

Library buffers (like most memory) in the Ruby IO class *are* shared between
different Threads and Fibers in Ruby.

Sharing of application buffers between Threads and Fibers is possible, but
usually not a good idea.

* The Unix Object Model (as seen in procfs)
Several filesystems have a procfs virtual filesystem mounted under [[file:/proc][/proc]],
although it doesn't seem to be standardized anywhere.

Among other things, procfs lets you see the relationship between process and
their file descriptors on the filesystem.

You can inspect which file descriptors a particular process is using by looking
in the "fd" subdirectory belonging to the PID of the process. For example, a
mutt process with PID 19245 and file descriptors 0, 1, 2, and 4 open would look
like this:

  /proc/19245/fd
  /proc/19245/fd/0
  /proc/19245/fd/1
  /proc/19245/fd/2
  /proc/19245/fd/4

Each PID has a directory in [[file:/proc][/proc]], and in each PID's directory there is an "fd"
folder.

Utilities like [[sh:man%201%20ps][ps(1)]] are likely to use information used in procfs to generate
their outpt. Other information in procfs is not consistent across
implementations, so consult your OS documentation for full details.

* Basic IO Methods
Consider C library functions (3) analogues, while the system call (2) functions
(3) are inevitably called by Ruby
** Opening and Closing Files
+ File.open :: [[shell:man%203%20fopen][fopen(3)]] which wraps [[shell:man%202%20open][open(2)]] and provides a File object
+ IO#close :: [[shell:man%203%20fclose][fclose(3)]], [[shell:man%202%20close][close(2)]] - Copies Ruby buffers to the kernel,
              invalidates the IO object and releases the file descriptor so it
              may be reused by the kernel.
** Some File Operations for Reading and Writing
+ IO#read :: [[man%203%20fread][fread(3)]] - read all specified bytes
+ IO#write :: [[shell:man%203%20fwrite][fwrite(3)]] - write all specified bytes
+ IO#sync, IO#sync= :: [[shell:man%203%20setvbuf][setvbuf(3)]] controls Ruby write buffering
+ IO#flush :: [[shell:man%204%20fflush][fflush(3)]] - copies existing Ruby write buffers to kernel
+ IO#syswrite :: [[shell:man%202%20write][write(2)]] - copies application buffers to kernel
+ IO#sysread :: [[shell:man%202%20read][copies kernel buffers to application]]


Setting IO#sync= to true will make IO#write copy application buffers directly
into kernel buffers, bypassing Ruby buffers. IO#sync does not influence read
buffering.

If IO#sync is false, IO#write may copy small application buffers into Ruby
buffers before doing IO#flush internally.

The non-sys* methods will retry until the operation is complete, or raise on any
errors. The sys* variants do not retry if the kernel returns a partial [[shell:man%202%20read][read(2)]]
or [[shell:man%202%20write][write(2)]], and will also raise on errors.

Mixing sys* and non-sys* methods is not recommended and will result in errors or
exceptions.

* Regular Files and Metadata
Regular files on a persistent filesystem are pointers or links to internal
metadata known as inodes. The implementation details of inodes varies between
various filesystems and is usually not the concern of user space. User space
developers should only need to know a few common traits about inodes
** device number (File::Stat#dev)
The device number is a unique integer identifier for the device an inode belongs
to. Each file system partition is considered its own "device", so a device
number does not necessarily correspond to a physical device.

A device number is unique within a running Unix system, no two "devices" may
have the same device number at the same time.
** inode number (File::Stat#ino)
The inode number is a unique integer identifier for an inode within a particular
device. Like PIDs, FDs, and device numbers, they are opaque pointers to complex
objects in kernel space.

The combination of device and inode number is required to uniquely identify any
inode (and thus file) in the system
** File Names
In many cases, there is a 1:1 relationship between file names and inodes. That
is, each file name points to its own inode, much like how one variable points to
one ruby object:

  ".bashrc" -> inode_number=123, device_number=456

It is important to know the file name -> inode relationship is one way. Inodes
do not know which file name(s) are pointing to them. Similarly, Ruby objects do
not know which variable name(s) are assigned to them.

When working with File objects, one should know that the File#path method return
value in Ruby is determined in user space with File.open is called, *not* when
File#path is called:

#+begin_src ruby
  file = File.open(".bashrc")
  file.path  # returns value or ".bashrc" determined above
#+end_src
** Creating Inodes and Files
Making the [[shell:man%202%20open][open(2)]] system call with the O_CREAT flag will create a file.

File.open can accept the equivalent IO::CREAT constant, or [[man%203%20fopen][fopen(3)]]-style mode
strings ("w", "a") to create an inode if the specified file name does not exist.

The Unix [[shell:man%201%20touch][touch(1)]] command and FileUtils.touch method both create files with
[[shell:man%202%20open][open(2)]] in this way. Historically there is also a [[shell:man%202%20creat][creat(2)]] system call for
creating and opening files, but [[shell:man%202%20open][open(2)]] is more flexible and preferred. Ruby
does not use nor expose [[man%202%20creat][creat(2)]] to the user.
** Hard Links
Since you should understand how two or more variables can point to the same
object in Ruby, you should be able to understand how two or more file names can
point to the same inode on one device.

Like two variables pointing to the same Ruby object, two or more links pointing
to the same inode are indistinguishable from each other. Hard links to existing
files are created with the File.link method, which makes the [[shell:man%202%20link][link(2)]] system
call. There is usually a system-dependent limit on the number of links to a
particular inode -- File.link will raise Errno::EMLINK if this limit is hit.
** Number of Hard Links (File::Stat#nlink)
While inodes do not know which file names point to it, inodes are aware of how
many file names point to it. Each time a hard link is created, the number of
hard links to the referenced inode is incremented.

File names may be removed with the [[man%202%20unlink][unlink(2)]] system call (via File.unlink in
Ruby). Unlinking a file will decrement the number of links an inode has. It is
possible for an inode to have zero links to it and still be valid.
** File::Stat
File::Stat is the Ruby class used to present inode information to the user. All
of the fields mentioned above are available from a File::Stat object.

File::Stat is a wrapper for the [[shell:man%202%20stat][stat(2)]] system call and returns a File::Stat
object for a given path.

If you have a Ruby IO object open, you can use IO#stat to get the File::Stat
object for the file descriptor belonging to the IO/File object. IO#Stat makes
the [[shell:man%202%20fstat][fstat(2)]] system call instead of [[shell:man%202%20stat][stat(2)]].

File::Stat is the Ruby equivalent/wrapper of the "struct stat" seen by C programmers.
* An Introduction to the Unix Pipe
The Unix pipe is an example of an anonymous file. Unlike regular files and
directories, anonymous files do not exist on the filesystem and do not persist
across reboots. Only the process that creates the anonymous file (and its
descendants) can access anonymous files. Anonymous files only persist until the
last process using it closes it.

At its heart, the Unix pipe is just like a pipe in plumbing: a one-way buffer
for transporting ayload from one end to another.

It is implemented as a circular ring buffer in the kernel:

#+begin_example
     user space | kernel space
----------------|--------------------------
data in --> fd[writer] ->- file[writer] -->\
                |                           \
                |                            [buffer]
                |                            /
data out <-- fd[reader] -<- file[reader] <--/
#+end_example

The buffer is created by the [[shell:man%202%20pipe][pipe(2)]] system call and persists until both files
are closed. In Ruby, the IO.pipe method calls [[shell:man%202%20pipe][pipe(2)]] and returns an array of
two Ruby IO objects, a reader and writer:

#+begin_src ruby
reader, writer = IO.pipe # kernel creates internal buffer
#+end_src

Writing can be accomplished by making the [[shell:man%202%20write][write(2)]] syscall, the writer IO object
should default to IO#sync=true at creation.

#+begin_src ruby
writer.write("HELLO")
#+end_src

Reading can be accomplished by making the [[shell:man%202%20read][read(2)]] syscall.

#+begin_src ruby
reader.read(5) # => "HELLO"
#+end_src

Finally, the kernel memory for the buffer is released after both file objects
(through file descriptors and IO) are closed:

#+begin_src ruby
writer.close
reader.close
# kernel frees the buffer
#+end_src

As with regular files, pipes operate on byte streams and leave higher-level
functionality like encoding to user sspace.

Pipes also have important atomicity requirements standardized by POSIX. Given
the importance of pipes in Unix programming, we will revisit and give pipes much
more coverage in the future.
* Directories on the Filesystem
Directories are containers for files in addition to being files. Similarly, Ruby
Hashes are containers for Objects in addition to being objects.

The contents of the "/home/johndoe/" directory could be expressed as the
following Ruby pseudocode:

#+begin_src ruby
  root = {
    "home" => {
      "johndoe" => {
        ".bashrc" => Inode[123],
        ".vimrc" => Inode[456],
        ".mutt" => {
          ".muttrc" => Inode[789]
        }
      }
    }
  }
#+end_src

It's impossible for two identical file names to appear in the same directory at
the same time.
** Directory Entries
As hashes are composed of key-value pairs, directories are composed of directory
entries, or "dirent" structures which store file names and inode numbers. Like
"struct stat" information, the "struct dirent" exposed to user space contains
only the standardized, common information for user space, not the actual,
private information in the kernel or file system.

Ruby does not expose the dirent structure in any way (the standard C library
does), but one could express the dirent structure with the following Ruby
Struct:

#+begin_src ruby
  Dirent = Struct.new(:d_name, :d_ino)
  Dirent.new(".bashrc", 123)
#+end_src
** Reading Dirents
The Ruby Dir class handles reading directories, but only exposes names to the
user.

There are no portable syscalls for reading dirents from a directory, only
standardized *library* functions such as [[shell:man%203%20readdir][readdir(3)]] and [[shell:man%203%20readdir_r][readdir_r(3)]]. These
library functions are wrappers for non-portable system calls.

Furthermore, common functionality like partial name matching (globbing) is
handled by user space. Proper Unix file systems have no notion of encoding or
case-sensitivity in kernel space, thus inexact name matching rules need to be
applied in user space.

Sorting is also done in user space. The standard C library functions never
guarantee entries are returned in any particular order. This behavior matches
the behavior of Hashes in Ruby 1.8 and earler. In fact, some file systems store
or index name-to-inode mappings in a hash structure on disk.

All dentries (except "..") within one directory belong to the same device, and
often the same physical device[fn:17], so only the inode number is stored in the
dirent.
** Creating and Removing Directories
Creating directories requires the [[shell:man%202%20mkdir][mkdir(2)]] syscall provided by the Ruby
Dir.mkdir method.

Once created, it is possible to use [[shell:man%202%20open][open(2)]] to "open" a directory like a regular
file and IO#stat it.

The [[shell:man%202%20rmdir][rmdir(2)]] syscall is used to remove directories, and is provided by Dir.rmdir
in Ruby.

High-level wrappers like FileUtils.mkpath (or "[[shell:man%201%20mkdir][mkdir(1)]] -p") and
FileUtils.rmtree (or "[[man%201%20rm][rm(1)]] -r") need to invoke the appropriate syscall for
every entry they wish to create or remove.

On modern Unicies, it is not possible to create hard links for
directories. Allowing directoriy hard links would lead to infinite recursion
loops when traversing directories.

Thus, the File::Stat#nlink field for directories shows the number of entries the
directory contains.
** "." and ".." entries
Every directory contains an entry for itself, ".", and to its parent, "..".

The root "/" directory is specal and is its own parent.
** [[man%202%20rename][rename(2)]]
The File.rename method wraps the [[shell:man%202%20rename][rename(2)]] syscall to change the name of a file
within the same device. [[man%202%20rename][rename(2)]] can occur within the same or different
directories as long as the source and destination exist on the same device.

For regular files:

#+begin_src ruby
File.rename("foo", "bar")
#+end_src

Is roughly equivalent to:

#+begin_src ruby
File.link("foo", "bar")
File.unlink("foo")
#+end_src

However, it is impossible (on a POSIX-compliant filesystem) for userspace to
access both "foo" and "bar" at the same time when using
File.rename. Additionally, File.rename will work on directories whereas
File.link and File.unlink do not work on directories.

Commands like [[man%201%20mv][mv(1)]] will use [[shell:man%202%20rename][rename(2)]] if both the source and destination exist
on the same device. This makes [[man%201%20mv][mv(1)]] very fast in cases where it works on the
same device, but slow and non-atomic if the source and destination need to cross
devices.

* Footnotes
[fn:1] or more

[fn:2] however, "POSIX-compliant" does not guarantee a system is Unix or even
"Unix-like". Old Unix systems are not "POSIX-compliant" either.

[fn:3] This is *not* the Kernel#system method in ruby, nor the corresponding C
library [[shell:man%203%20system][system(3)]] function! In fact, the ruby module "Kernel" has little to do
with operating system kernels.

[fn:4] as in beer and in speech

[fn:5] although experimental Multi-VM implementations exist that allow multiple
Ruby VMs within a single process

[fn:6] even for non-storage tasks

[fn:7] the intended successor to Unix

[fn:8] among others

[fn:9] including pseudo

[fn:10] libc

[fn:11] explaining why this is so expensve is left as an exercise for the reader

[fn:12] and subclasses like File

[fn:13] e.g.: [[shell:man%203%20malloc][malloc(3)]] in libc

[fn:14] via [[shell:man%202%20brk][brk(2)]], [[shell:man%202%20sbrk][sbrk(2)]], [[shell:man%202%20mmap][mmap(2)]], or various non-portable methods.

[fn:15] Multiple IO objects may wrap a sngle file descriptor, but that can be a
bad idea.

[fn:16] database servers like PostGreSQL come to mind

[fn:17] There exists some union filesystems which break this assumption, however
they are uncommon and often restricted to read-only access.
